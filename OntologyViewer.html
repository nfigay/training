<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OWL Validation</title>
    <script src="https://unpkg.com/rdflib/dist/rdflib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pure-uuid@latest/uuid.min.js"></script>
    <script src="https://unpkg.com/ulid@2.3.0/dist/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/layout-base/layout-base.js"></script>
    <script src="https://unpkg.com/cose-base/cose-base.js"></script>
    <script src="https://unpkg.com/cytoscape-fcose/cytoscape-fcose.js"></script>
    <script src="lib/cytoscape-expand-collapse.js"></script>

    <style>
        select {
            width: 100%;
            height: 200px;
            margin: 10px 0;
            padding: 5px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            font-family: Arial, sans-serif;
            overflow: auto;
        }

        #cy {
            width: 100%;
            height: 600px;
            border: 1px solid black;
        }

        #infoPanel {
            border: 1px solid black;
            padding: 10px;
            width: 20%;
            height: 80%;
            position: absolute;
            top: 50px;
            right: 20px;
            background-color: #f9f9f9;
            overflow: auto;
            /* Permet d'ajouter des barres de défilement */
        }

        #infoPanel h3 {
            margin-top: 0;
        }
    </style>
</head>

<body>
    <h1>Viewer Fichier OWL</h1>
    <input type="file" id="fileInput" />
    <button id="validateButton">Visualisation Fichier OWL</button>
    <div id="cy"></div>
    <div id="infoPanel">
        <h3>Informations</h3>
        <p><strong>ID:</strong> <span id="Id">N/A</span><br />
            <strong>Label:</strong> <span id="Label">N/A</span>
        </p>
        <p><strong>IRI:</strong> <span id="IRI">N/A</span><br />
            <strong>Statement:</strong> <span id="Statement">N/A</span><br />
            <strong>Type:</strong> <span id="Type">N/A</span><br>


    </div>


    <div id="output">
        <label for="classesSelect">Classes OWL trouvées :</label>
        <select id="classesSelect" size="10"></select>

        <label for="classEquivalenceSelect">Classes d'équivalence entre propriétés :</label>
        <select id="classEquivalenceSelect" size="10"></select>

        <label for="objectPropertiesSelect">Propriétés objets OWL trouvées :</label>
        <select id="objectPropertiesSelect" size="10"></select>

        <label for="namedIndividualsSelect">Individus nommés OWL trouvés :</label>
        <select id="namedIndividualsSelect" size="10"></select>
        <label for="isaRelationsSelect">Relations de typage d'individus :</label>
        <select id="isaRelationsSelect" size="10"></select>

        <label for="classSubsumptionSelect">Relations de subsomption entre classes :</label>
        <select id="classSubsumptionSelect" size="10"></select>

        <label for="propertySubsumptionSelect">Relations de subsomption entre propriétés :</label>
        <select id="propertySubsumptionSelect" size="10"></select>

        <label for="propertyEquivalenceSelect">Relations d'équivalence entre propriétés :</label>
        <select id="propertyEquivalenceSelect" size="10"></select>


        <label for="propertyInverseSelect">Relations inverse entre propriétés :</label>
        <select id="propertyInverseSelect" size="10"></select>


        <label for="individualRelationsSelect">Relations entre individus :</label>
        <select id="individualRelationsSelect" size="10"></select>

        <label for="domainsSelect">Déclarations de domaines :</label>
        <select id="domainsSelect" size="10"></select>

        <label for="rangesSelect">Déclarations de portées :</label>
        <select id="rangesSelect" size="10"></select>

    </div>

    <script>

        let store; // Déclare le store comme variable globale
        // Stocke les groupes d'équivalence avec leurs UUID
        var nodes = [];
        var edges = [];
        var equivalenceGroups = new Map();


        // Create Node Function
        function createNode(id, label, type, IRI, parent = null) {

            // Prepare the node data
            const nodeData = {
                id,
                label,
                type,
                IRI
            };

            // Add the parent only if it is defined
            if (parent) {
                nodeData.parent = parent;
            }

            // Push the node data to the array
            nodes.push({
                group: 'nodes',
                data: nodeData,
                classes: type
            });
            //console.log(nodeData)
        }



        function createEdge(id, label, source, target, type) {
            // Retrieve the style for the given type


            // Prepare the edge data
            const edgeData = {
                id,
                label,
                source,
                target
            };

            // Push the edge data to the edges array
            edges.push({
                group: 'edges',
                data: edgeData,
                classes: type // Optional: Keep the class for additional styling
            });
        }

        /**
          * Met à jour ou crée un nœud avec l'attribut 'parent'.
          *
          * @param {string} iri - Identifiant unique de l'IRI.
          * @param {string} groupID - Identifiant du groupe d'équivalence.
          */
        function updateOrCreateNode(iri, groupID, type) {
            // Recherche un nœud existant avec cet IRI
            const existingNode = nodes.find(node => node.data.id === iri);
            const existingGroupIDNode = nodes.find(node => node.data.id === groupID);
            //   alert(JSON.stringify(existingNode))

            if (existingNode) {
                // Met à jour l'attribut 'parent' du nœud existant
                existingNode.data.parent = groupID;
            } else {
                // Crée un nouveau nœud si aucun nœud existant n'est trouvé
                if (type === "OWLProperty") {
                    createNode(iri, node.data.label, 'property', iri, groupID);
                }
                else { createNode(iri, node.data.label, 'class', iri, groupID); }
            }
            if (!existingGroupIDNode) {
                // Crée un nouveau nœud si aucun nœud existant n'est trouvé
                if (type === "OWLProperty") {
                    createNode(groupID, "≡", 'property', "", type);
                } else {
                    createNode(groupID, "≡", 'class', "", type);
                }
            }
        }



        // Fonction pour traiter une équivalence de propriété
        function processEquivalence(iriA, iriB, type) {
            console.log(iriA + " equivalent to" + iriB)
            let groupID;
            // Vérifie si un groupe d'équivalence existe déjà pour l'un des IRI
            for (let [id, set] of equivalenceGroups) {
                if (set.has(iriA) || set.has(iriB)) {
                    groupID = id;
                    set.add(iriA);
                    set.add(iriB);
                    break;
                }
            }
            // Si aucune correspondance n'a été trouvée, crée un nouveau groupe d'équivalence
            if (!groupID) {
                groupID = ULID.ulid();
                equivalenceGroups.set(groupID, new Set([iriA, iriB]));
            }
            // Mise à jour ou création des nœuds
            updateOrCreateNode(iriA, groupID, type);
            updateOrCreateNode(iriB, groupID, type);

            return groupID;
        }

        // Fonction pour détecter le format du fichier RDF
        function detectFormat(data) {
            if (data.trim().startsWith('<?xml')) {
                return 'application/rdf+xml'; // RDF/XML
            } else if (data.trim().startsWith('{') || data.trim().startsWith('[')) {
                return 'application/ld+json'; // JSON-LD
            } else if (data.includes('@prefix') || data.includes('@base')) {
                return 'text/turtle'; // Turtle
            } else {
                throw new Error("Format RDF non détecté ou non supporté.");
            }
        }

        function generateNodeId(iri) {
            return iri.replace(/[^a-zA-Z0-9]/g, '_');
        }

        function getLabelFromIRI(iri) {
            const hashIndex = iri.lastIndexOf('#');
            if (hashIndex !== -1 && hashIndex < iri.length - 1) {
                // Si un # est trouvé et qu'il n'est pas à la fin, renvoyer ce qui est après
                return iri.substring(hashIndex + 1);
            }

            const slashIndex = iri.lastIndexOf('/');
            if (slashIndex !== -1 && slashIndex < iri.length - 1) {
                // Si aucun # ou si le # est à la fin, renvoyer ce qui est après le dernier /
                return iri.substring(slashIndex + 1);
            }
            // Si aucun / ou # significatif n'est trouvé, retourner l'IRI complet
            return iri;
        }

        function displayLabelsOnDoubleClick(resource, store, containerId) {
            // Add event listener for double click
            document.getElementById(containerId).addEventListener('dblclick', function () {
                // Get all possible label types (rdfs:label, skos:prefLabel, etc.)
                const labelPredicates = [
                    'http://www.w3.org/2000/01/rdf-schema#label',
                    'http://www.w3.org/2004/02/skos/core#prefLabel',
                    'http://www.w3.org/2004/02/skos/core#altLabel',
                ];

                const labels = [];

                // Iterate over predicates to fetch all labels
                labelPredicates.forEach(predicate => {
                    const foundLabels = store.each(resource, $rdf.sym(predicate), null);
                    foundLabels.forEach(label => {
                        labels.push({
                            type: predicate.split('#')[1], // Extract 'label', 'prefLabel', etc.
                            lang: label.lang || 'none',   // Language of the label
                            text: label.value             // Text of the label
                        });
                    });
                });

                // Check if labels are found
                if (labels.length === 0) {
                    alert('No labels found for this resource.');
                    return;
                }

                // Generate HTML list of labels
                let html = '<ul>';
                labels.forEach(label => {
                    html += `
                <li>
                    <strong>Type:</strong> ${label.type}<br>
                    <strong>Language:</strong> ${label.lang}<br>
                    <strong>Text:</strong> ${label.text}
                </li>
            `;
                });
                html += '</ul>';

                // Display the HTML in a container
                const container = document.getElementById(containerId);
                container.innerHTML = html;
            });
        }

        const rdfType = $rdf.sym('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
        const namedIndividual = $rdf.sym('http://www.w3.org/2002/07/owl#NamedIndividual');
        const objectProperty = $rdf.sym('http://www.w3.org/2002/07/owl#ObjectProperty');
        const rdfsSubClassOf = $rdf.sym('http://www.w3.org/2000/01/rdf-schema#subClassOf');
        const rdfsSubPropertyOf = $rdf.sym('http://www.w3.org/2000/01/rdf-schema#subPropertyOf');
        const owlEquivalentProperty = $rdf.sym('http://www.w3.org/2002/07/owl#equivalentProperty');
        const owlEquivalentClass = $rdf.sym('http://www.w3.org/2002/07/owl#equivalentClass');
        const owlInverseProperty = $rdf.sym('http://www.w3.org/2002/07/owl#inverseOf');
        const rdfsDomain = $rdf.sym("http://www.w3.org/2000/01/rdf-schema#domain");
        const rdfsRange = $rdf.sym("http://www.w3.org/2000/01/rdf-schema#range");
        const owlClass = $rdf.sym('http://www.w3.org/2002/07/owl#Class');
        const label = $rdf.sym('http://www.w3.org/2000/01/rdf-schema#label')
        const propertyChainAxiom = $rdf.sym("http://www.w3.org/2002/07/owl#propertyChainAxiom")
        const owlOntology = $rdf.sym('http://www.w3.org/2002/07/owl#Ontology');
        const owlImports = $rdf.sym('http://www.w3.org/2002/07/owl#imports');

        // Function to extract any label from a resource (no language filter)
        function getLabelFromResource(resourceURI, store) {
            try {

                // Create a RDF resource symbol
                const resource = $rdf.sym(resourceURI);
                // Get all possible label types (rdfs:label, skos:prefLabel, etc.)
                const labelPredicates = [
                    'http://www.w3.org/2000/01/rdf-schema#label',
                    'http://www.w3.org/2004/02/skos/core#prefLabel',
                    'http://www.w3.org/2004/02/skos/core#altLabel',
                ];

                var labels = [];
                // Iterate over predicates to fetch all labels
                labelPredicates.forEach(predicate => {
                    const foundLabels = store.each(resource, $rdf.sym(predicate), null);
                    foundLabels.forEach(label => {
                        labels.push({
                            type: predicate.split('#')[1], // Extract 'label', 'prefLabel', etc.
                            lang: label.lang || 'none',   // Language of the label
                            text: label.value             // Text of the label
                        });
                    });
                });
                // Check if labels are found
                if (labels.length === 0) {
                    alert('No labels found for this resource.');
                    return;
                }

                // Generate HTML list of labels
                let html = '<ul>';
                labels.forEach(label => {
                    html += `
                <li>
                    <strong>Type:</strong> ${label.type}<br>
                    <strong>Language:</strong> ${label.lang}<br>
                    <strong>Text:</strong> ${label.text}
                </li>`;
                });
                html += '</ul>';

                // Display the HTML in a container
                alert(html)

                // Query the RDF store for rdfs:label values
                labels = store.each(resource, $rdf.sym('http://www.w3.org/2000/01/rdf-schema#label'), null);

                // Check if labels exist
                if (labels.length === 0) {
                    console.log(`No labels found for resource: ${resourceURI}`);
                    return 'No Label'; // Default label if none found
                }

                // Extract and return labels as a string
                const allLabels = labels.map(label => label.value).join(', ');
                console.log(`Labels found: ${allLabels}`);
                return allLabels;
            } catch (error) {
                console.error(`Error retrieving label for resource ${resourceURI}:`, error);
                return 'Error'; // Return a default error label
            }
        }

        // Function to generate a graph with Cytoscape.js from the property chains
        function generateGraphFromPropertyChains(chains) {
            const elements = [];
            const propertyMap = new Map();
            chains.forEach((chain, chainIndex) => {
                // Add a node for the property chain itself
               
                const chainNodeId = ULID.ulid();
                var  propertyChainDerivedProperty=chains.property
                createNode(chainNodeId, `PropertyChain ${chainIndex + 1}`, "propertychain", "", chain.property);
                
                let previousNodeId = null;
                

                // Add nodes for each property in the chain and its elements
                chain.chain.forEach((property, propertyIndex) => {
                    const propertyNodeId = `property-${propertyIndex}-${chainIndex}`;
                    
                    const blankNodeId = `blank-${propertyIndex}-${chainIndex}`;
                    console.log(`Property value:${property}`)

                    //createNode(id, label, type, IRI, parent = null)
                     createNode(blankNodeId, `${propertyIndex + 1}`, "chainmember", "", chainNodeId);
        

                    // If it's not the first element, create an edge between the previous and the next
                    if (previousNodeId) {
                    //    function createEdge(id, label, source, target, type)
                    createEdge(ULID.ulid(),'', previousNodeId, blankNodeId, 'nextchainmember')
                    }

                    // Create an edge between the "Blank" node and the property node
                    createEdge(ULID.ulid(), `${propertyIndex + 1}`, blankNodeId,property, 'nextchaintype')
                    

                    // Update previousNodeId
                    previousNodeId = blankNodeId;
                });

                // Create an edge between the chain node and the first property in the chain
                //createEdge(ULID.ulid(), 'Starts', chainNodeId, `property-0-${chainIndex}`, 'nextchainmember')
               
            });
        }

        // Function to extract property chains from the store
        function extractPropertyChains(store) {
            const propertyChains = [];


            // Find all owl:propertyChainAxiom axioms
            store.statementsMatching(undefined, $rdf.sym("http://www.w3.org/2002/07/owl#propertyChainAxiom")).forEach(statement => {
                // If the statement contains a propertyChainAxiom
                if (statement.object && statement.object.elements && Array.isArray(statement.object.elements)) {
                    // Extract the elements of the property chain
                    const chain = statement.object.elements.map(el => el.value);
                    propertyChains.push({
                        chain: chain,
                        property: statement.subject.value // Property associated with the chain
                    });
                }
            });

            return propertyChains;
        }

        // Fonction de validation OWL
        function validateOWL(store) {
            nodes = [];
            edges = [];
            const uniqueNodeIds = new Set();

            // Query for the ontology IRI searching for the firt occurence of owlOntoloyg with store.any
            const ontologyIRI = store.any(undefined, rdfType, owlOntology);
            // Log the extracted ontology IRI
            createNode(ontologyIRI.value, getLabelFromIRI(ontologyIRI.value), "ontology", ontologyIRI.value, "");

            // Imports          
            const imports = store.each(ontologyIRI, owlImports);
            if (imports.length > 0) {
                imports.forEach((importedOntology) => {
                    console.log(`Imported Ontology: ${importedOntology.value}`);
                    createNode(importedOntology.value, importedOntology.value, "ontology", importedOntology.value, "");
                    createEdge(ULID.ulid(), "import", ontologyIRI.value, importedOntology.value, "import")
                });
            } else {
                console.log('No imports found');
            }

            const classes = store.each(null, rdfType, owlClass);
            createNode("OWLClass", "OWLClasses", "class", owlClass.value, ontologyIRI.value);
            createNode("OWLProperty", "OWLProperties", "property", objectProperty.value, ontologyIRI.value);
            createNode("OWLIndividual", "OWLIndividuals", "individual", namedIndividual.value, ontologyIRI.value);
            // createNode("http://www.w3.org/2002/07/owl#topObjectProperty", "topObjectProperty", "property", objectProperty.value, "OWLProperty");

            const allProperties = store.statementsMatching(null, null, null); // Toutes les relations de triplets

            // Clear previous content in dropdowns
            document.getElementById('classesSelect').innerHTML = '';
            document.getElementById('objectPropertiesSelect').innerHTML = '';
            document.getElementById('namedIndividualsSelect').innerHTML = '';
            document.getElementById('isaRelationsSelect').innerHTML = '';
            document.getElementById('classSubsumptionSelect').innerHTML = '';
            document.getElementById('propertySubsumptionSelect').innerHTML = '';
            document.getElementById('propertyEquivalenceSelect').innerHTML = '';
            document.getElementById('classEquivalenceSelect').innerHTML = '';
            document.getElementById('individualRelationsSelect').innerHTML = '';
            document.getElementById('domainsSelect').innerHTML = '';
            document.getElementById('rangesSelect').innerHTML = '';

            // Classes OWL
            const classesSelect = document.getElementById('classesSelect');
            // Vérifier qu'au moins une classe OWL est définie            
            if (classes.length === 0) {
                const option = document.createElement('option');
                option.textContent = "Aucune classe OWL trouvée !";
                classesSelect.appendChild(option);
            } else {
                classes.forEach(cls => {
                    const option = document.createElement('option');
                    option.textContent = cls.value;
                    classesSelect.appendChild(option);

                    const label = getLabelFromIRI(cls.value);
                    const nodeId = cls.value;
                    uniqueNodeIds.add(nodeId);
                    createNode(nodeId, label, 'class', cls.value, 'OWLClass');

                });
            }

            // ObjectProperties OWL
            const objectProperties = store.each(null, rdfType, $rdf.sym('http://www.w3.org/2002/07/owl#ObjectProperty'));
            const objectPropertiesSelect = document.getElementById('objectPropertiesSelect');
            // Vérifier qu'au moins une propriété objet (ObjectProperty) est définie
            if (objectProperties.length === 0) {
                const option = document.createElement('option');
                option.textContent = "Aucune propriété objet OWL trouvée !";
                objectPropertiesSelect.appendChild(option);
            } else {
                objectProperties.forEach(prop => {
                    const option = document.createElement('option');
                    option.textContent = prop.value;
                    objectPropertiesSelect.appendChild(option);

                    const propertyIRI = prop.value;
                    const label = getLabelFromIRI(propertyIRI);
                    const propertyId = propertyIRI;

                    uniqueNodeIds.add(propertyId);
                    createNode(propertyId, label, 'property', prop.value, 'OWLProperty');
                    createNode(propertyId + "_domain", 'domain', 'oprd', prop.value, propertyId);
                    createNode(propertyId + "_range", 'range', 'oprd', prop.value, propertyId);
                    //   createEdge(propertyId + '_toRange', "", propertyId, propertyId + "_range", "range");
                    //   createEdge(propertyId + '_toDomain', "", propertyId, propertyId + "_domain", "domain");
                })

            }

            //NamedIndividuals OWL
            const namedIndividuals = store.each(null, rdfType, namedIndividual);
            const namedIndividualsSelect = document.getElementById('namedIndividualsSelect');
            // Vérifier qu'au moins un individu nommé (NamedIndividual) est défini
            if (namedIndividuals.length === 0) {
                const option = document.createElement('option');
                option.textContent = "Aucun individu nommé trouvé !";
                namedIndividualsSelect.appendChild(option);
            } else {
                namedIndividuals.forEach(individual => {
                    const option = document.createElement('option');
                    option.textContent = individual.value;
                    namedIndividualsSelect.appendChild(option);

                    const label = getLabelFromIRI(individual.value);
                    const nodeId = individual.value;
                    if (!uniqueNodeIds.has(nodeId)) {
                        uniqueNodeIds.add(nodeId);
                        createNode(nodeId, label, 'individual', individual.value, 'OWLIndividual');
                    }
                });
            }

            // Gestion de l'affichage des relations `isa` entre individus et classes
            const isaSelect = document.getElementById('isaRelationsSelect');
            if (namedIndividuals.length === 0) {
                const option = document.createElement('option');
                option.textContent = "Aucun individu typé trouvé !";
                isaSelect.appendChild(option);
            } else {
                namedIndividuals.forEach(individual => {
                    // Trouver toutes les classes associées à cet individu via rdf:type
                    const relatedClasses = store.each(individual, rdfType, null);
                    relatedClasses.forEach(cls => {
                        // Vérifier si la classe est une vraie classe OWL
                        if (store.holds(cls, rdfType, owlClass)) {
                            // Ajouter la relation dans l'interface
                            const option = document.createElement('option');
                            option.textContent = `${individual.value} -> ${cls.value}`;
                            isaSelect.appendChild(option);

                            // Créer des noeuds ou connexions dans votre graphe
                            const individualLabel = getLabelFromIRI(individual.value);
                            const classLabel = getLabelFromIRI(cls.value);
                            createEdge(ULID.ulid(), "isa", individual.value, cls.value, 'isa');

                        }
                    });
                });
            }

            // Sous classes
            var classSubsumption
            classes.forEach(classe => {

                //const classSubsumption = store.statementsMatching(null, rdfsSubClassOf, null);
                const classSubsumptionSelect = document.getElementById('classSubsumptionSelect');
                // Recherchez les définitions de sous classes spécifiques à cette classe
                const subclasses = store.statementsMatching(classe, rdfsSubClassOf, null);
                if (subclasses.length === 0) {
                } else {
                    subclasses.forEach(subclass => {
                        const option = document.createElement('option');
                        option.textContent = `${classe.value} ⊆ ${subclass.object.value}`;
                        classSubsumptionSelect.appendChild(option);

                        const subjectId = classe.value;
                        const objectId = subclass.object.value; // Subclass target is the object
                        const edgeId = `${subjectId} -subclassof-> ${objectId}`;
                        if (!edges.some(edge => edge.data.id === edgeId)) { // Avoid duplicate edges
                            createEdge(edgeId, "", subjectId, objectId, 'subClass');
                        }
                    });
                }
                // Equivalences de classes
                const equivalentClasses = store.statementsMatching(classe, owlEquivalentClass, null);

                // Traitez les propriétés équivalentes trouvées
                equivalentClasses.forEach(equivalentclass => {
                    const option = document.createElement('option');
                    option.textContent = `${classe.value} ≡ ${equivalentclass.object.value}`;
                    classEquivalenceSelect.appendChild(option);

                    const subjectId = classe.value
                    const objectId = equivalentclass.object.value;
                    const edgeId = `${subjectId}-equivalentclass-${objectId}`;
                    createEdge(edgeId, "", subjectId, objectId, 'equivalentClass');
                    processEquivalence(subjectId, objectId, "OWLClass")
                });


            });

            const propertyEquivalenceSelect = document.getElementById('propertyEquivalenceSelect');
            objectProperties.forEach(property => {

                // Equivalences de propriété
                const equivalentProperties = store.statementsMatching(property, owlEquivalentProperty, null);

                // Traitez les propriétés équivalentes trouvées
                equivalentProperties.forEach(equivalentproperty => {
                    // Skip owl:topObjectProperty
                    const option = document.createElement('option');
                    option.textContent = `${property.value} ≡ ${equivalentproperty.object.value}`;
                    propertyEquivalenceSelect.appendChild(option);

                    const subjectId = property.value
                    const objectId = equivalentproperty.object.value;
                    const edgeId = `${subjectId}-equivalentproperty-${objectId}`;
                    createEdge(edgeId, "", subjectId, objectId, 'equivalentProperty');
                    processEquivalence(subjectId, objectId, "OWLProperty")
                });

                // Sous Propriétés
                const owlTopProperty = 'http://www.w3.org/2002/07/owl#topObjectProperty';
                const propertySubsumptionSelect = document.getElementById('propertySubsumptionSelect');

                const subproperties = store.statementsMatching(property, rdfsSubPropertyOf, null);

                subproperties.forEach(subproperty => {
                    // Skip owl:topObjectProperty
                    if (subproperty.object.value === owlTopProperty) {
                        return;
                    }
                    const option = document.createElement('option');
                    option.textContent = `${property.value} ⊑ ${subproperty.object.value}`;
                    propertySubsumptionSelect.appendChild(option);

                    const subjectId = property.value
                    const objectId = subproperty.object.value;
                    const edgeId = `${subjectId}-subpropertyof-${objectId}`;
                    createEdge(edgeId, "", subjectId, objectId, 'subProperty');
                });


                // Relations d'inverse entre propriétés
                const propertyInverseSelect = document.getElementById('propertyInverseSelect');
                const inverseProperties = store.statementsMatching(property, owlInverseProperty, null);

                inverseProperties.forEach(inverseProperty => {
                    // Créez une option dans le sélecteur
                    const option = document.createElement('option');
                    option.textContent = `${property.value} ⟲ ${inverseProperty.object.value}`;
                    propertyInverseSelect.appendChild(option);

                    // Créez une arête pour représenter la relation inverse dans un graphe
                    const subjectId = property.value;
                    const objectId = inverseProperty.object.value;
                    const edgeId = `${subjectId}-inverseproperty-${objectId}`;
                    createEdge(edgeId, "", subjectId, objectId, 'inverseProperty');
                });

            });

            //domaines
            const domainsSelect = document.getElementById('domainsSelect');
            const domains = [];
            const domainStatements = store.statementsMatching(null, rdfsDomain, null);
            domainStatements.forEach(domainClass => {
                if (domainStatements.length === 0) {
                    const option = document.createElement('option');
                    option.textContent = "Aucune définition de domaine trouvée !";
                    domainsSelect.appendChild(option);
                } else {
                    const option = document.createElement('option');
                    const subject = domainClass.subject.value;
                    const predicate = domainClass.predicate.value;
                    const object = domainClass.object.value;
                    option.textContent = `${subject} -- ${predicate} --> ${object}`;
                    domainsSelect.appendChild(option);

                    // Ajouter une arête entre la propriété et la classe de domaine
                    const subjectId = domainClass.subject.value;
                    const objectId = domainClass.object.value;
                    const edgeId = `${subjectId}-domain-${objectId}`;
                    createEdge(edgeId, "", subjectId + "_domain", objectId, 'domain');

                }
            });

            //range
            const rangesSelect = document.getElementById('rangesSelect');
            const ranges = [];
            const rangeStatements = store.statementsMatching(null, rdfsRange, null);
            rangeStatements.forEach(rangeClass => {

                if (rangeStatements.length === 0) {
                    const option = document.createElement('option');
                    option.textContent = "Aucune définition de portée trouvée !";
                    rangesSelect.appendChild(option);
                } else {
                    const option = document.createElement('option');
                    const subject = rangeClass.subject.value;
                    const predicate = rangeClass.predicate.value;
                    const object = rangeClass.object.value;
                    option.textContent = `${subject} -- ${predicate} --> ${object}`;
                    rangesSelect.appendChild(option);

                    // Ajouter une arête entre la propriété et la classe de domaine
                    const subjectId = rangeClass.subject.value;
                    const objectId = rangeClass.object.value;
                    const edgeId = `${subjectId}-range-${objectId}`;
                    createEdge(edgeId, "", subjectId + "_range", objectId, 'range');
                }
            });


            //relations
            // Filtrer tous les triplets où l'objet est une ressource (qu'elle soit NamedNode ou BlankNode)
            const objectPropertiesUsed = store.statementsMatching(null, null, null);

            // Extraire les prédicats qui sont des ObjectProperties et dont l'objet est une ressource
            const objectPropertiesSet = new Set();
            objectPropertiesUsed.forEach(triplet => {
                const predicate = triplet.predicate;
                const object = triplet.object;

                // Vérifier si le prédicat est un ObjectProperty
                if (store.statementsMatching(predicate, rdfType, objectProperty).length > 0) {
                    // Vérifier si l'objet est une ressource (NamedNode ou BlankNode)
                    if (object.termType === 'NamedNode' || object.termType === 'BlankNode') {
                        objectPropertiesSet.add(predicate.value); // Ajouter le prédicat à la liste des ObjectProperties utilisées
                    }
                }
            });


            //Chaines de propriétés
            // Extract property chains from RDF
            const propertyChains = extractPropertyChains(store);
            generateGraphFromPropertyChains(propertyChains);



            //typed links between individual
            const individualRelationsSelect = document.getElementById('individualRelationsSelect');
            const individualRelations = [];
            // Afficher toutes les ObjectProperties utilisées dans les relations entre individus
            objectPropertiesSet.forEach(pred => {
                // Relations entre individus : Extraction simple des triplets
                const myProperty = $rdf.sym(pred);
                const myPropertyInstances = store.statementsMatching(null, myProperty, null);
                if (myPropertyInstances.length === 0) {
                    const option = document.createElement('option');
                    option.textContent = "Aucune relation de type " + pred + " entre individus trouvée !";
                    individualRelationsSelect.appendChild(option);
                } else {
                    myPropertyInstances.forEach(relation => {
                        const option = document.createElement('option');
                        const subject = relation.subject.value;
                        const predicate = relation.predicate.value;
                        const object = relation.object.value;
                        option.textContent = `${subject} -- ${predicate} --> ${object}`;
                        individualRelationsSelect.appendChild(option);

                        const objectId = object;
                        const subjectId = subject;
                        const predicateId = predicate;

                        const edgeId = `${subjectId}-${predicateId}->${objectId}`
                        createEdge(edgeId, predicate, subjectId, objectId, 'relation');
                    });
                }
            });

            //initialisation du graphe
            cy.elements().remove();
            cy.add(nodes);
            edges.forEach(edge => {
                try {
                    // Add the edge directly using its existing data
                    cy.add({
                        group: 'edges',
                        data: edge.data,
                        classes: edge.classes
                    });
                } catch (error) {
                    // Log the error to the console with details about the edge
                    console.error(`Failed to add edge with ID: ${edge.data.id}`, error);
                    console.log('Edge data:', edge.data);
                }
            });
            cy.layout({
                name: 'fcose',
                fit: true, // Fit to viewport
                padding: 10, // Padding around the layout
                nodeDimensionsIncludeLabels: true, // Avoid overlap due to labels
                randomize: true, // Use pre-defined positions as the initial state

                // Compactness and overlap minimization
                idealEdgeLength: 50, // Ideal length of edges
                edgeElasticity: 0.2, // Elasticity of edges
                gravity: 1, // Overall gravity force
                gravityRange: 1.5, // Range for gravity
                gravityCompound: 2, // Gravity for compound/nested nodes
                gravityRangeCompound: 1.5, // Range for compound gravity
                nodeSeparation: 20, // Minimum separation between nodes
                packingMode: 'all', // Compactly pack nodes in compound nodes

                // Fine-tuning energy model
                numIter: 2500, // Number of iterations
                tile: true, // Arrange disconnected components in a tiled manner
                tilingPaddingVertical: 20, // Vertical padding for tiled components
                tilingPaddingHorizontal: 20, // Horizontal padding for tiled components
                step: 'all', // Run all steps of the algorithm
            }).run();

            console.log("Ontology successfully imported into Cytoscape!");

        }

        // Gestionnaire d'événements pour valider le fichier OWL
        document.getElementById('validateButton').addEventListener('click', () => {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert("Veuillez sélectionner un fichier OWL.");
                return;
            }

            const reader = new FileReader();

            reader.onload = (event) => {
                const data = event.target.result;

                let format;
                try {
                    format = detectFormat(data);
                    alert(`Format RDF détecté : ${format}`);
                } catch (error) {
                    alert(`Erreur de détection du format RDF : ${error.message}`);
                    return;
                }

                // Base IRI par défaut
                const baseIRI = 'http://example.org/ontology#';

                // Créer un store RDF
                store = $rdf.graph();

                // Parsing RDF
                $rdf.parse(data, store, baseIRI, format, (error) => {
                    if (error) {
                        alert(`Erreur lors du parsing RDF : ${error}`);
                        return;
                    }
                    alert(`Parsing réussi. Nombre de triplets chargés : ${store.statements.length}`);

                    validateOWL(store);
                });
            };

            reader.readAsText(file);
        });


        const cy = cytoscape({
            container: document.getElementById('cy'),
            layout: { name: 'fcose' },
            ready: function () {
                this.layout({
                    name: 'fcose',
                    randomize: true,
                    animate: false,
                    fit: true, // Fit to viewport
                    padding: 10, // Padding around the layout
                    nodeDimensionsIncludeLabels: true, // Avoid overlap due to labels
                    randomize: false, // Use pre-defined positions as the initial state

                    // Compactness and overlap minimization
                    idealEdgeLength: 50, // Ideal length of edges
                    edgeElasticity: 0.2, // Elasticity of edges
                    gravity: 1, // Overall gravity force
                    gravityRange: 1.5, // Range for gravity
                    gravityCompound: 2, // Gravity for compound/nested nodes
                    gravityRangeCompound: 1.5, // Range for compound gravity
                    nodeSeparation: 20, // Minimum separation between nodes
                    packingMode: 'all', // Compactly pack nodes in compound nodes

                    // Fine-tuning energy model
                    numIter: 2500, // Number of iterations
                    tile: true, // Arrange disconnected components in a tiled manner
                    tilingPaddingVertical: 20, // Vertical padding for tiled components
                    tilingPaddingHorizontal: 20, // Horizontal padding for tiled components
                    step: 'all', // Run all steps of the algorithm
                }).run();
                var api = this.expandCollapse({
                    layoutBy: {
                        name: "fcose",
                        animate: true,
                        randomize: true,
                        fit: true, // Fit to viewport
                        padding: 10, // Padding around the layout
                        nodeDimensionsIncludeLabels: true, // Avoid overlap due to labels
                        randomize: false, // Use pre-defined positions as the initial state

                        // Compactness and overlap minimization
                        idealEdgeLength: 50, // Ideal length of edges
                        edgeElasticity: 0.2, // Elasticity of edges
                        gravity: 1, // Overall gravity force
                        gravityRange: 1.5, // Range for gravity
                        gravityCompound: 2, // Gravity for compound/nested nodes
                        gravityRangeCompound: 1.5, // Range for compound gravity
                        nodeSeparation: 20, // Minimum separation between nodes
                        packingMode: 'all', // Compactly pack nodes in compound nodes

                        // Fine-tuning energy model
                        numIter: 2500, // Number of iterations
                        tile: true, // Arrange disconnected components in a tiled manner
                        tilingPaddingVertical: 20, // Vertical padding for tiled components
                        tilingPaddingHorizontal: 20, // Horizontal padding for tiled components
                        step: 'all', // Run all steps of the algorithm
                    },
                    fisheye: true,
                    animate: true,
                    undoable: false
                });
                api.collapseAll();
            },
            elements: [],
            style: [
                // Node styles (for different types of nodes)
                {
                    selector: ':parent',
                    style: {
                        'background-opacity': 0.333
                    }
                },
                // Collapsed node styling
                {
                    selector: "node.cy-expand-collapse-collapsed-node",
                    style: {
                        "background-color": "darkblue",
                        "shape": "rectangle"
                    }
                },
                // Selected node styling
                {
                    selector: ':selected',
                    style: {
                        'overlay-color': "#6c757d",
                        'overlay-opacity': 0.3,
                        'background-color': "#999999"
                    }
                },
                {
                    selector: 'node',
                    style: {
                        'label': 'data(label)',
                        'text-halign': 'center',
                        'text-valign': 'top',
                        'color': 'black',
                    }
                },
                {
                    selector: 'node.class',
                    style: {
                        'background-color': '#FFA500', // Orange for class nodes
                        'shape': 'ellipse',
                    }
                },
                {
                    selector: 'node.property',
                    style: {
                        'background-color': '#0074D9', // Blue for property nodes
                        'shape': 'square',
                    }
                },
                {
                    selector: 'node.individual',
                    style: {
                        'background-color': '#800080', // Purple for individual nodes
                        'shape': 'diamond',
                    }
                },
                {
                    selector: 'node.oprd',
                    style: {
                        'background-color': 'white', // White for domain nodes
                        'shape': 'ellipse',
                    }
                },
                {
                    selector: 'node.propertychain',
                    style: {
                        'background-color': 'green', // green for PropertyChainNode
                        'shape': 'rectangle',
                    }
                },
                {
                    selector: 'node.chainmember',
                    style: {
                        'background-color': 'yellow', // Yellow for PropertyChainMemberNode
                        'shape': 'rectangle',
                    }
                },
                // Node style: equivalence
                {
                    selector: 'node.equivalence',
                    style: {
                        'background-color': '#0074D9', // Blue for property nodes
                        'shape': 'square',
                        'label': '≡',              // Equivalence symbol as label
                        'text-background-color': '#fff', // Background for the label
                        'text-background-opacity': 1,    // Make the background fully visible
                        'text-background-padding': 2,    // Add padding around the label
                        'text-background-shape': 'roundrectangle', // Shape of the background
                    }
                },



                // Edge styles (with arrows)
                {
                    selector: 'edge',
                    style: {
                        'width': 3,
                        'curve-style': 'bezier',
                        'target-arrow-color': 'black',
                        'line-color': '#999',
                        'label': 'data(label)',
                    }
                },
                // Edge style: isa
                {
                    selector: 'edge.isa',
                    style: {
                        'line-color': 'blue',
                        'width': 1,
                        'label': "isa"
                    }
                },
                // Edge style: relation
                {
                    selector: 'edge.relation',
                    style: {
                        'line-color': 'black',
                        'source-arrow-shape': 'none',
                        'target-arrow-shape': 'vee',
                        'arrow-scale': 1.5,
                        'label': function (ele) {
                            // Get the label from data and apply the transformation
                            const label = ele.data('label');
                            return getLabelFromIRI(label);  // Apply getLabelFromIRI to the label
                        },
                    }
                },
                // Edge style: domainE
                {
                    selector: 'edge.domain',
                    style: {
                        'label': 'D',
                        'line-color': 'blue',
                        'source-arrow-shape': 'none',
                        'target-arrow-shape': 'none',
                        'arrow-scale': 1,
                        'width': 1
                    }
                },
                // Edge style: rangeE
                {
                    selector: 'edge.range',
                    style: {
                        'label': 'R',
                        'line-color': 'blue',
                        'source-arrow-shape': 'none',
                        'target-arrow-shape': 'none',
                        'arrow-scale': 1,
                        'width': 1
                    }
                },
                // Edge style: subProperty
                {
                    selector: 'edge.subProperty',
                    style: {
                        'line-color': '#000000',  // Black line color for the edge
                        'line-style': 'solid',    // Solid line style
                        'width': 1,               // Edge width for visibility
                        'target-arrow-shape': 'triangle', // Use a square shape for the arrow
                        'target-arrow-color': '#000000',  // Matching color for the arrow
                        'source-arrow-shape': 'none', // No source arrow
                        'label': '',              // No label on the specialization edge
                        'arrow-scale': 1.5,       // Scale the arrow size for better visibility
                        'target-arrow-fill': 'hollow'  // Hollow rectangle (border only)

                    }
                },
                // Edge style: equivalentProperty
                {
                    selector: 'edge.equivalentProperty',
                    style: {
                        'line-color': '#000000',  // Black line color for the edge
                        'line-style': 'solid',    // Solid line style
                        'width': 1,               // Edge width for visibility
                        'label': '≡',              // Equivalence symbol as label
                        'text-background-color': '#fff', // Background for the label
                        'text-background-opacity': 1,    // Make the background fully visible
                        'text-background-padding': 2,    // Add padding around the label
                        'text-background-shape': 'roundrectangle', // Shape of the background

                    }
                },
                // Edge style: inverseProperty
                {
                    selector: 'edge.inverseProperty',
                    style: {
                        'line-color': '#000000',  // Black line color for the edge
                        'line-style': 'solid',    // Solid line style
                        'width': 1,               // Edge width for visibility
                        'label': '⟲',              // Inverse symbol as label
                        'text-background-color': '#fff', // Background for the label
                        'text-background-opacity': 1,    // Make the background fully visible
                        'text-background-padding': 2,    // Add padding around the label
                        'text-background-shape': 'roundrectangle', // Shape of the background

                    }
                },
                // Edge chain property next chain member
                {
                    selector: 'edge.nextchainmember',
                    style: {
                        'line-color': '#000000',  // Black line color for the edge
                        'line-style': 'solid',    // Solid line style
                        'width': 1,               // Edge width for visibility
                        'label': '',              // Inverse symbol as label
                        'target-arrow-shape': 'vee', // Use a square shape for the arrow
                        'target-arrow-color': '#000000',  // Matching color for the arrow
                        'source-arrow-shape': 'none', // No source arrow                      
                    }
                },
                // Edge chain property next chain member type
                {
                    selector: 'edge.nextchaintype',
                    style: {
                        'line-color': 'green',  // Black line color for the edge
                        'line-style': 'solid',    // Solid line style
                        'width': 1,               // Edge width for visibility
                        'target-arrow-shape': 'none', // Use a square shape for the arrow
                        'source-arrow-shape': 'none', // No source arrow                      
                    }
                },
                // Edge style: subClass
                {
                    selector: 'edge.subClass',
                    style: {
                        'line-color': '#000000',  // Black line color for the edge
                        'line-style': 'solid',    // Solid line style
                        'width': 1,               // Edge width for visibility
                        'target-arrow-shape': 'triangle', // Use a square shape for the arrow
                        'target-arrow-color': '#000000',  // Matching color for the arrow
                        'source-arrow-shape': 'none', // No source arrow
                        'label': '',              // No label on the specialization edge
                        'arrow-scale': 1.5,       // Scale the arrow size for better visibility
                        'target-arrow-fill': 'hollow'  // Hollow rectangle (border only)

                    }
                }
            ]

        });


        // Event listener for double-click
        cy.on('dblclick', 'node, edge', function (evt) {
            const element = evt.target;  // The clicked element
            const elementClasses = element.classes();  // Get the classes of the clicked element

            // Retrieve the data attributes from the clicked element
            const elementID = element.id();  // Get the classes of the clicked element

            const elementType = element.data('type') || 'No type';  // Get the type from data, or default if not present
            const elementLabel = element.data('label') || 'No label';  // Get the label, or default if not present
            const elementIRIType = element.data('IRI') || 'No IRI';  // Get the label, or default if not present

            const elementDescription = element.data('description') || 'No description';  // Get the description, or default if not present

            // Display information in an alert
            //   alert(`IDShort: ${elementLabel}\nID: ${elementID}\nType: ${elementType}\nClasses: ${elementClasses.join(', ')}\nIRIType: ${elementIRIType}\nDescription: ${elementDescription}`);
            const labelContainerId = 'labelContainer';
            try {
                getLabelFromResource(element.id(), store)
            } catch { console.log("Error when capturing label") }
        });


        // Gestion du double-clic ou du tap
        cy.on('tap', 'node, edge', function (event) {
            const target = event.target;

            // Récupérer les informations détaillées de l'élément
            const id = target.data('id');
            const label = target.data('label');
            const iri = target.data('IRI');
            const type = target.data('type');
            const superTypes = [];
            const sourceTarget = target.data('source') ? `Source: ${target.data('source')}, Target: ${target.data('target')}` : 'N/A';
            const Target = target.data('target') ? `${target.data('target')}` : 'N/A';
            const Source = target.data('source') ? `${target.data('source')}` : 'N/A';
            const Statement = target.data('statement') ? `${target.data('statement')}` : 'N/A';

            // Mettre à jour le panneau d'informations
            document.getElementById('Id').textContent = id;
            document.getElementById('Label').textContent = label;
            document.getElementById('IRI').textContent = iri;
            document.getElementById('Type').textContent = type;
            document.getElementById('Statement').textContent = Statement;
        });
    </script>
</body>

</html>