<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Import OWL into Cytoscape</title>
    <script src="https://cdn.jsdelivr.net/npm/rdflib/dist/rdflib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/layout-base/layout-base.js"></script>
    <script src="https://unpkg.com/cose-base/cose-base.js"></script>
    <script src="https://unpkg.com/cytoscape-fcose/cytoscape-fcose.js"></script>
    <script src="lib/cytoscape-expand-collapse.js"></script>

    <style>
        #cy {
            width: 100%;
            height: 600px;
            border: 1px solid black;
        }

        #infoPanel {
            border: 1px solid black;
            padding: 10px;
            width: 300px;
            height: 300px;
            position: absolute;
            top: 50px;
            right: 20px;
            background-color: #f9f9f9;
            overflow: auto;
            /* Permet d'ajouter des barres de défilement */
        }

        #infoPanel h3 {
            margin-top: 0;
        }
    </style>
</head>

<body>

    <input type="file" id="fileInput" />
    <div id="cy"></div>
    <div id="infoPanel">
        <h3>Informations</h3>
        <p><strong>ID:</strong> <span id="nodeId">N/A</span></p>
        <p><strong>Label:</strong> <span id="nodeLabel">N/A</span></p>
        <p><strong>IRI:</strong> <span id="nodeIRI">N/A</span></p>
        <p><strong>Type:</strong> <span id="nodeType">N/A</span></p>
        <p><strong>Super Types:</strong> <span id="nodeSuperTypes">N/A</span></p>
        <p><strong>Source/Target:</strong> <span id="nodeSourceTarget">N/A</span></p>
    </div>

    <script>
        let store; // Déclare le store comme variable globale

        function getLabelFromIRI(iri) {
            const hashIndex = iri.lastIndexOf('#');
            if (hashIndex !== -1 && hashIndex < iri.length - 1) {
                // Si un # est trouvé et qu'il n'est pas à la fin, renvoyer ce qui est après
                return iri.substring(hashIndex + 1);
            }

            const slashIndex = iri.lastIndexOf('/');
            if (slashIndex !== -1 && slashIndex < iri.length - 1) {
                // Si aucun # ou si le # est à la fin, renvoyer ce qui est après le dernier /
                return iri.substring(slashIndex + 1);
            }

            // Si aucun / ou # significatif n'est trouvé, retourner l'IRI complet
            return iri;
        }

        function generateNodeId(iri) {
            return iri.replace(/[^a-zA-Z0-9]/g, '_');
        }

        async function importOntologyFromFile(file, cyInstance) {
            const $rdf = window.$rdf;
            store = $rdf.graph();  // Initialise le store global
            const parser = $rdf.parse;

            try {
                const fileContent = await file.text();
                parser(fileContent, store, "http://example.org/base#", "application/rdf+xml");

                const nodes = [];
                const edges = [];

                const nodeIcons = {
                    class: { shape: 'ellipse', color: '#FFA500' },
                    domain: { shape: 'ellipse', color: 'rgba(255, 255, 255, 0.5)' },
                    range: { shape: 'ellipse', color: 'rgba(255, 255, 255, 0.5)' },
                    individual: { shape: 'diamond', color: '#8A2BE2' },
                    property: { shape: 'rectangle', color: '#1E90FF' }
                };
                nodes.push({
                    data: { id: "OWLClass", label: "OWLClasses", shape: nodeIcons.class.shape, color: nodeIcons.class.color, iri: "http://www.w3.org/2002/07/owl#Class", type: 'class' }
                });
                nodes.push({
                    data: { id: "OWLProperty", label: "OWLProperties", shape: nodeIcons.property.shape, color: nodeIcons.property.color, iri: "http://www.w3.org/2002/07/owl#ObjectProperty", type: 'property' }
                });
                nodes.push({
                    data: { id: "OWLIndividual", label: "OWLIndividuals", shape: nodeIcons.individual.shape, color: nodeIcons.individual.color, iri: "http://www.w3.org/2002/07/owl#Individual", type: 'individual' }
                });

                const uniqueNodeIds = new Set();

                const classType = $rdf.sym("http://www.w3.org/2002/07/owl#Class");
                const rdfsSubClassOf = $rdf.sym("http://www.w3.org/2000/01/rdf-schema#subClassOf");
                const rdfsDomain = $rdf.sym("http://www.w3.org/2000/01/rdf-schema#domain");
                const rdfsRange = $rdf.sym("http://www.w3.org/2000/01/rdf-schema#range");
                const rdfsSubPropertyOf = $rdf.sym("http://www.w3.org/2000/01/rdf-schema#subPropertyOf");

                // Iterate over all classes
                store.each(null, $rdf.sym("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), classType)
                    .forEach(cls => {
                        if (cls && cls.value) { // Ensure cls is valid
                            const label = getLabelFromIRI(cls.value);
                            const nodeId = generateNodeId(cls.value);

                            // Add class as a node if not already added
                            if (!uniqueNodeIds.has(nodeId)) {
                                uniqueNodeIds.add(nodeId);
                                nodes.push({
                                    data: { id: nodeId, label: label, shape: nodeIcons.class.shape, color: nodeIcons.class.color, iri: cls.value, type: 'class', parent: 'OWLClass' }
                                });
                            }

                            // Find subclass relationships
                            store.each(cls, rdfsSubClassOf, null).forEach(subClassTarget => {
                                if (subClassTarget && subClassTarget.value) { // Ensure target is valid
                                    const subjectId = nodeId; // Current class is the subject
                                    const objectId = generateNodeId(subClassTarget.value); // Subclass target is the object

                                    const edgeId = `${subjectId}-subclassof-${objectId}`;
                                    if (!edges.some(edge => edge.data.id === edgeId)) { // Avoid duplicate edges
                                        edges.push({
                                            data: {
                                                id: edgeId,
                                                source: subjectId,
                                                target: objectId,
                                                label: 'subclassof',
                                                iri: rdfsSubClassOf.value,
                                                type: "subclassof"
                                            }
                                        });
                                    }
                                }
                            });
                        }
                    });
                const namedIndividualType = $rdf.sym("http://www.w3.org/2002/07/owl#NamedIndividual");
                const instanceOf = $rdf.sym("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
                store.each(null, instanceOf, null).forEach(individual => {
                    const type = store.any(individual, instanceOf);
                    // Vérifier si l'individu est bien un NamedIndividual
                    if (type && type.uri === namedIndividualType.uri) {
                        const label = getLabelFromIRI(individual.value);
                        const nodeId = generateNodeId(individual.value);
                        if (!uniqueNodeIds.has(nodeId)) {
                            uniqueNodeIds.add(nodeId);
                            nodes.push({
                                data: { id: nodeId, label: label, shape: nodeIcons.individual.shape, color: nodeIcons.individual.color, iri: individual.value, type: 'individual', parent: 'OWLIndividual' }
                            });
                        }
                    }
                });

                const objectPropertyType = $rdf.sym("http://www.w3.org/2002/07/owl#ObjectProperty");

                store.each(null, null, objectPropertyType).forEach(property => {
                    const propertyIRI = property.value;
                    const label = getLabelFromIRI(propertyIRI);
                    const propertyId = generateNodeId("OP_" + propertyIRI);
                    if (!uniqueNodeIds.has(propertyId)) {
                        uniqueNodeIds.add(propertyId);
                        nodes.push({
                            data: { id: propertyId, label: label, shape: nodeIcons.property.shape, color: nodeIcons.property.color, iri: propertyIRI, type: 'property', parent: 'OWLProperty' }
                        });
                        nodes.push({
                            data: { id: 'domain' + propertyId, label: "domain", shape: nodeIcons.domain.shape, color: nodeIcons.domain.color, type: 'domain', parent: 'OWLProperty' }
                        });
                        nodes.push({
                            data: { id: 'range' + propertyId, label: "range", shape: nodeIcons.range.shape, color: nodeIcons.range.color, type: 'range', parent: 'OWLProperty' }
                        });
                        edges.push({
                            data: {
                                id: 'toRange' + propertyId, source: propertyId, target: 'range' + propertyId, label: "", type: "OPRD"
                            }
                        });
                        edges.push({
                            data: {
                                id: 'toDomain' + propertyId, target: propertyId, source: 'domain' + propertyId, label: "", type: "OPRD"
                            }
                        });
                    }


                    // Gérer les relations subPropertyOf
                    store.each(property, rdfsSubPropertyOf, null).forEach(parentProperty => {
                        const parentPropertyIRI = parentProperty.value;
                        const parentPropertyId = generateNodeId("OP_" + parentPropertyIRI);

                        // Ajouter un nœud pour la propriété parent si elle n'existe pas encore
                        if (!uniqueNodeIds.has(parentPropertyId)) {
                            uniqueNodeIds.add(parentPropertyId);
                            nodes.push({
                                data: {
                                    id: parentPropertyId,
                                    label: getLabelFromIRI(parentPropertyIRI),
                                    shape: nodeIcons.property.shape,
                                    color: nodeIcons.property.color,
                                    iri: parentPropertyIRI,
                                    type: 'property',
                                    parent: 'OWLProperty'
                                }
                            });
                        }

                        // Ajouter une arête pour la relation subPropertyOf
                        const edgeId = `${propertyId}-subpropertyof-${parentPropertyId}`;
                        if (!edges.some(edge => edge.data.id === edgeId)) {
                            edges.push({
                                data: {
                                    id: edgeId,
                                    source: propertyId,
                                    target: parentPropertyId,
                                    label: 'subPropertyOf',
                                    iri: rdfsSubPropertyOf.value,
                                    type: 'subpropertyof'
                                }
                            });
                        }

                    });
                    // Gérer les relations avec les classes de domaine et de range
                    store.each(property, rdfsDomain, null).forEach(domainClass => {
                        const domainClassIRI = domainClass.value;
                        const domainClassId =  generateNodeId(domainClassIRI);

                        // Ajouter un nœud pour la classe de domaine si elle n'existe pas encore
                        if (!uniqueNodeIds.has(domainClassId)) {
                            uniqueNodeIds.add(domainClassId);
                            nodes.push({
                                data: {
                                    id: domainClassId,
                                    label: getLabelFromIRI(domainClassIRI),
                                    shape: nodeIcons.class.shape,
                                    color: nodeIcons.class.color,
                                    iri: domainClassIRI,
                                    type: 'class',
                                    parent: 'OWLClass'
                                }
                            });
                        }

                        // Ajouter une arête entre la propriété et la classe de domaine
                        const edgeId = `${propertyId}-domain-${domainClassId}`;
                        if (!edges.some(edge => edge.data.id === edgeId)) {
                            edges.push({
                                data: {
                                    id: edgeId,
                                    source: 'domain'+propertyId,
                                    target: domainClassId,
                                //    label: 'rdfs:domain',
                                    iri: rdfsDomain.value,
                                    type: 'domain'
                                }
                            });
                        }
                    });

                    store.each(property, rdfsRange, null).forEach(rangeClass => {
                        const rangeClassIRI = rangeClass.value;
                        const rangeClassId = generateNodeId(rangeClassIRI);

                        // Ajouter un nœud pour la classe de range si elle n'existe pas encore
                        if (!uniqueNodeIds.has(rangeClassId)) {
                            uniqueNodeIds.add(rangeClassId);
                            nodes.push({
                                data: {
                                    id: rangeClassId,
                                    label: getLabelFromIRI(rangeClassIRI),
                                    shape: nodeIcons.class.shape,
                                    color: nodeIcons.class.color,
                                    iri: rangeClassIRI,
                                    type: 'class',
                                    parent: 'OWLClass'
                                }
                            });
                        }

                        // Ajouter une arête entre la propriété et la classe de range
                        const edgeId = `${propertyId}-range-${rangeClassId}`;
                        if (!edges.some(edge => edge.data.id === edgeId)) {
                            edges.push({
                                data: {
                                    id: edgeId,
                                    source: 'range'+propertyId,
                                    target: rangeClassId,
                                   // label: 'rdfs:range',
                                    iri: rdfsRange.value,
                                    type: 'range'
                                }
                            });
                        }
                    });

                    store.each(null, property, null).forEach(subject => {
                        const subjectId = generateNodeId(subject.value);
                        store.each(subject, property, null).forEach(object => {
                            const objectId = generateNodeId(object.value);
                            const edgeId = subjectId + '-' + propertyId + '-' + objectId;

                            edges.push({
                                data: {
                                    id: edgeId,
                                    source: subjectId,
                                    target: objectId,
                                    label: label,
                                    iri: propertyIRI
                                }
                            });
                        });
                    });



                    store.each(null, property, null).forEach(subject => {

                        const subjectId = generateNodeId(subject.value);
                        store.each(subject, property, null).forEach(object => {
                            const objectId = generateNodeId(object.value);
                            const edgeId = subjectId + '-' + propertyId + '-' + objectId;
                            alert(edgeId)

                            edges.push({
                                data: {
                                    id: edgeId,
                                    source: subjectId,
                                    target: objectId,
                                    label: label,
                                    iri: propertyIRI
                                }
                            });
                        });
                    });
                });

                cyInstance.elements().remove();
                cyInstance.add(nodes);
                cyInstance.add(edges);
                cyInstance.layout({
                    name: 'fcose',
                    fit: true, // Fit to viewport
                    padding: 10, // Padding around the layout
                    nodeDimensionsIncludeLabels: true, // Avoid overlap due to labels
                    randomize: true, // Use pre-defined positions as the initial state

                    // Compactness and overlap minimization
                    idealEdgeLength: 50, // Ideal length of edges
                    edgeElasticity: 0.2, // Elasticity of edges
                    gravity: 1, // Overall gravity force
                    gravityRange: 1.5, // Range for gravity
                    gravityCompound: 2, // Gravity for compound/nested nodes
                    gravityRangeCompound: 1.5, // Range for compound gravity
                    nodeSeparation: 20, // Minimum separation between nodes
                    packingMode: 'all', // Compactly pack nodes in compound nodes

                    // Fine-tuning energy model
                    numIter: 2500, // Number of iterations
                    tile: true, // Arrange disconnected components in a tiled manner
                    tilingPaddingVertical: 20, // Vertical padding for tiled components
                    tilingPaddingHorizontal: 20, // Horizontal padding for tiled components
                    step: 'all', // Run all steps of the algorithm
                }).run();

                console.log("Ontology successfully imported into Cytoscape!");
            } catch (error) {
                console.error("Failed to parse RDF/XML data: ", error);
                alert("Error parsing the OWL file. Please ensure it's in valid RDF/XML format.");
            }
        }

        const cy = cytoscape({
            container: document.getElementById('cy'),
            layout: { name: 'fcose' },
            ready: function () {
                this.layout({
                    name: 'fcose',
                    randomize: true,
                    fit: true,
                    animate: false,
                    fit: true, // Fit to viewport
                    padding: 10, // Padding around the layout
                    nodeDimensionsIncludeLabels: true, // Avoid overlap due to labels
                    randomize: false, // Use pre-defined positions as the initial state

                    // Compactness and overlap minimization
                    idealEdgeLength: 50, // Ideal length of edges
                    edgeElasticity: 0.2, // Elasticity of edges
                    gravity: 1, // Overall gravity force
                    gravityRange: 1.5, // Range for gravity
                    gravityCompound: 2, // Gravity for compound/nested nodes
                    gravityRangeCompound: 1.5, // Range for compound gravity
                    nodeSeparation: 20, // Minimum separation between nodes
                    packingMode: 'all', // Compactly pack nodes in compound nodes

                    // Fine-tuning energy model
                    numIter: 2500, // Number of iterations
                    tile: true, // Arrange disconnected components in a tiled manner
                    tilingPaddingVertical: 20, // Vertical padding for tiled components
                    tilingPaddingHorizontal: 20, // Horizontal padding for tiled components
                    step: 'all', // Run all steps of the algorithm
                }).run();
                var api = this.expandCollapse({
                    layoutBy: {
                        name: "fcose",
                        animate: true,
                        randomize: true,
                        fit: true,
                        fit: true, // Fit to viewport
                        padding: 10, // Padding around the layout
                        nodeDimensionsIncludeLabels: true, // Avoid overlap due to labels
                        randomize: false, // Use pre-defined positions as the initial state

                        // Compactness and overlap minimization
                        idealEdgeLength: 50, // Ideal length of edges
                        edgeElasticity: 0.2, // Elasticity of edges
                        gravity: 1, // Overall gravity force
                        gravityRange: 1.5, // Range for gravity
                        gravityCompound: 2, // Gravity for compound/nested nodes
                        gravityRangeCompound: 1.5, // Range for compound gravity
                        nodeSeparation: 20, // Minimum separation between nodes
                        packingMode: 'all', // Compactly pack nodes in compound nodes

                        // Fine-tuning energy model
                        numIter: 2500, // Number of iterations
                        tile: true, // Arrange disconnected components in a tiled manner
                        tilingPaddingVertical: 20, // Vertical padding for tiled components
                        tilingPaddingHorizontal: 20, // Horizontal padding for tiled components
                        step: 'all', // Run all steps of the algorithm
                    },
                    fisheye: true,
                    animate: true,
                    undoable: false
                });
                api.collapseAll();
            },
            elements: [],
            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': 'data(color)',
                        'label': 'data(label)',
                        'shape': 'data(shape)',
                        'width': 40,
                        'height': 40
                    }
                },
                {
                    selector: ':parent',
                    style: {
                        'background-opacity': 0.333
                    }
                },
                {
                    selector: "node.cy-expand-collapse-collapsed-node",
                    style: {
                        "background-color": "darkblue",
                        "shape": "rectangle"
                    }
                },
                {
                    selector: ':selected',
                    style: {
                        'overlay-color': "#6c757d",
                        'overlay-opacity': 0.3,
                        'background-color': "#999999"
                    }
                },

                {
                    selector: 'domain',
                    style: {
                        'background-color': 'data(color)',
                        'label': 'data(label)',
                        'shape': 'data(shape)',
                        'width': 40,
                        'height': 40,
                        'line-style': 'dashed'
                    }
                },
                {
                    selector: 'range',
                    style: {
                        'background-color': 'data(color)',
                        'label': 'data(label)',
                        'shape': 'data(shape)',
                        'width': 40,
                        'height': 40,
                        'line-style': 'dashed'
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 3,
                        'line-color': 'black',
                        'target-arrow-color': 'black',
                        'target-arrow-shape': 'triangle',
                        'label': 'data(label)',
                        'curve-style': 'bezier', // Makes the edge easier to distinguish
                        'line-style': 'solid'
                    }
                },
                {
                    // Style for edges of type "OPRD"
                    selector: 'edge[type = "OPRD"]',
                    style: {
                        'line-color': 'blue',
                        'width': 4,
                        'label': 'data(label)',
                        'curve-style': 'bezier',
                        'target-arrow-shape': 'none',
                    }
                },


                {
                    selector: 'edge.cy-expand-collapse-collapsed-edge',
                    style:
                    {
                        "text-outline-color": "#ffffff",
                        "text-outline-width": "2px",
                        'label': (e) => {
                            return '(' + e.data('collapsedEdges').length + ')';
                        },
                        'width': function (edge) {
                            const n = edge.data('collapsedEdges').length;
                            return (3 + Math.log2(n)) + 'px';
                        },
                        'line-style': 'dashed',

                    }
                }
            ],

        });

        document.getElementById('fileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (file) {
                importOntologyFromFile(file, cy);
            }
        });

        // Gestion du double-clic ou du tap
        cy.on('tap', 'node, edge', function (event) {
            const target = event.target;

            // Récupérer les informations détaillées de l'élément
            const id = target.data('id');
            const label = target.data('label');
            const iri = target.data('iri');
            const type = target.data('type');
            const superTypes = [];
            const sourceTarget = target.data('source') ? `Source: ${target.data('source')}, Target: ${target.data('target')}` : 'N/A';

            // Récupérer les super types pour les classes ou les propriétés
            if (type === 'class' || type === 'property') {
                const superClasses = store.each($rdf.sym(iri), $rdf.sym('http://www.w3.org/2000/01/rdf-schema#subClassOf'), null);
                const superProperties = store.each($rdf.sym(iri), $rdf.sym('http://www.w3.org/2002/07/owl#subPropertyOf'), null);
                superTypes.push(...superClasses.map(s => getLabelFromIRI(s.value)));
                superTypes.push(...superProperties.map(s => getLabelFromIRI(s.value)));
            }

            // Mettre à jour le panneau d'informations
            document.getElementById('nodeId').textContent = id;
            document.getElementById('nodeLabel').textContent = label;
            document.getElementById('nodeIRI').textContent = iri;
            document.getElementById('nodeType').textContent = type;
            document.getElementById('nodeSuperTypes').textContent = superTypes.join(', ') || 'N/A';
            document.getElementById('nodeSourceTarget').textContent = sourceTarget;
        });
    </script>

</body>

</html>